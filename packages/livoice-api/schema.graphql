# This file is automatically generated by Keystone, do not modify it manually.
# Modify your Keystone config when you want to change this.

type Chat {
  id: ID!
  title: String
  org: Organization
  project: Project
  transcript: Transcript
  messages(where: ChatMessageWhereInput! = {}, orderBy: [ChatMessageOrderByInput!]! = [], take: Int, skip: Int! = 0, cursor: ChatMessageWhereUniqueInput): [ChatMessage!]
  messagesCount(where: ChatMessageWhereInput! = {}): Int
  createdAt: DateTime
  updatedAt: DateTime
}

scalar DateTime @specifiedBy(url: "https://datatracker.ietf.org/doc/html/rfc3339#section-5.6")

input ChatWhereUniqueInput {
  id: ID
}

input ChatWhereInput {
  AND: [ChatWhereInput!]
  OR: [ChatWhereInput!]
  NOT: [ChatWhereInput!]
  id: IDFilter
  title: StringFilter
  org: OrganizationWhereInput
  project: ProjectWhereInput
  transcript: TranscriptWhereInput
  messages: ChatMessageManyRelationFilter
  createdAt: DateTimeNullableFilter
  updatedAt: DateTimeNullableFilter
}

input IDFilter {
  equals: ID
  in: [ID!]
  notIn: [ID!]
  lt: ID
  lte: ID
  gt: ID
  gte: ID
  not: IDFilter
}

input StringFilter {
  equals: String
  in: [String!]
  notIn: [String!]
  lt: String
  lte: String
  gt: String
  gte: String
  contains: String
  startsWith: String
  endsWith: String
  mode: QueryMode
  not: NestedStringFilter
}

enum QueryMode {
  default
  insensitive
}

input NestedStringFilter {
  equals: String
  in: [String!]
  notIn: [String!]
  lt: String
  lte: String
  gt: String
  gte: String
  contains: String
  startsWith: String
  endsWith: String
  not: NestedStringFilter
}

input ChatMessageManyRelationFilter {
  every: ChatMessageWhereInput
  some: ChatMessageWhereInput
  none: ChatMessageWhereInput
}

input DateTimeNullableFilter {
  equals: DateTime
  in: [DateTime!]
  notIn: [DateTime!]
  lt: DateTime
  lte: DateTime
  gt: DateTime
  gte: DateTime
  not: DateTimeNullableFilter
}

input ChatOrderByInput {
  id: OrderDirection
  title: OrderDirection
  createdAt: OrderDirection
  updatedAt: OrderDirection
}

enum OrderDirection {
  asc
  desc
}

input ChatUpdateInput {
  title: String
  org: OrganizationRelateToOneForUpdateInput
  project: ProjectRelateToOneForUpdateInput
  transcript: TranscriptRelateToOneForUpdateInput
  messages: ChatMessageRelateToManyForUpdateInput
  createdAt: DateTime
  updatedAt: DateTime
}

input OrganizationRelateToOneForUpdateInput {
  create: OrganizationCreateInput
  connect: OrganizationWhereUniqueInput
  disconnect: Boolean
}

input ProjectRelateToOneForUpdateInput {
  create: ProjectCreateInput
  connect: ProjectWhereUniqueInput
  disconnect: Boolean
}

input TranscriptRelateToOneForUpdateInput {
  create: TranscriptCreateInput
  connect: TranscriptWhereUniqueInput
  disconnect: Boolean
}

input ChatMessageRelateToManyForUpdateInput {
  disconnect: [ChatMessageWhereUniqueInput!]
  set: [ChatMessageWhereUniqueInput!]
  create: [ChatMessageCreateInput!]
  connect: [ChatMessageWhereUniqueInput!]
}

input ChatUpdateArgs {
  where: ChatWhereUniqueInput!
  data: ChatUpdateInput!
}

input ChatCreateInput {
  title: String
  org: OrganizationRelateToOneForCreateInput
  project: ProjectRelateToOneForCreateInput
  transcript: TranscriptRelateToOneForCreateInput
  messages: ChatMessageRelateToManyForCreateInput
  createdAt: DateTime
  updatedAt: DateTime
}

input OrganizationRelateToOneForCreateInput {
  create: OrganizationCreateInput
  connect: OrganizationWhereUniqueInput
}

input ProjectRelateToOneForCreateInput {
  create: ProjectCreateInput
  connect: ProjectWhereUniqueInput
}

input TranscriptRelateToOneForCreateInput {
  create: TranscriptCreateInput
  connect: TranscriptWhereUniqueInput
}

input ChatMessageRelateToManyForCreateInput {
  create: [ChatMessageCreateInput!]
  connect: [ChatMessageWhereUniqueInput!]
}

type ChatMessage {
  id: ID!
  chat: Chat
  role: String
  content: String
  segments(where: TranscriptSegmentWhereInput! = {}, orderBy: [TranscriptSegmentOrderByInput!]! = [], take: Int, skip: Int! = 0, cursor: TranscriptSegmentWhereUniqueInput): [TranscriptSegment!]
  segmentsCount(where: TranscriptSegmentWhereInput! = {}): Int
  createdAt: DateTime
}

input ChatMessageWhereUniqueInput {
  id: ID
}

input ChatMessageWhereInput {
  AND: [ChatMessageWhereInput!]
  OR: [ChatMessageWhereInput!]
  NOT: [ChatMessageWhereInput!]
  id: IDFilter
  chat: ChatWhereInput
  role: StringFilter
  content: StringFilter
  segments: TranscriptSegmentManyRelationFilter
  createdAt: DateTimeNullableFilter
}

input TranscriptSegmentManyRelationFilter {
  every: TranscriptSegmentWhereInput
  some: TranscriptSegmentWhereInput
  none: TranscriptSegmentWhereInput
}

input ChatMessageOrderByInput {
  id: OrderDirection
  role: OrderDirection
  content: OrderDirection
  createdAt: OrderDirection
}

input ChatMessageUpdateInput {
  chat: ChatRelateToOneForUpdateInput
  role: String
  content: String
  segments: TranscriptSegmentRelateToManyForUpdateInput
  createdAt: DateTime
}

input ChatRelateToOneForUpdateInput {
  create: ChatCreateInput
  connect: ChatWhereUniqueInput
  disconnect: Boolean
}

input TranscriptSegmentRelateToManyForUpdateInput {
  disconnect: [TranscriptSegmentWhereUniqueInput!]
  set: [TranscriptSegmentWhereUniqueInput!]
  create: [TranscriptSegmentCreateInput!]
  connect: [TranscriptSegmentWhereUniqueInput!]
}

input ChatMessageUpdateArgs {
  where: ChatMessageWhereUniqueInput!
  data: ChatMessageUpdateInput!
}

input ChatMessageCreateInput {
  chat: ChatRelateToOneForCreateInput
  role: String
  content: String
  segments: TranscriptSegmentRelateToManyForCreateInput
  createdAt: DateTime
}

input ChatRelateToOneForCreateInput {
  create: ChatCreateInput
  connect: ChatWhereUniqueInput
}

input TranscriptSegmentRelateToManyForCreateInput {
  create: [TranscriptSegmentCreateInput!]
  connect: [TranscriptSegmentWhereUniqueInput!]
}

type Organization {
  id: ID!
  name: String
  autojoinDomains: JSON
  users(where: UserWhereInput! = {}, orderBy: [UserOrderByInput!]! = [], take: Int, skip: Int! = 0, cursor: UserWhereUniqueInput): [User!]
  usersCount(where: UserWhereInput! = {}): Int
  projects(where: ProjectWhereInput! = {}, orderBy: [ProjectOrderByInput!]! = [], take: Int, skip: Int! = 0, cursor: ProjectWhereUniqueInput): [Project!]
  projectsCount(where: ProjectWhereInput! = {}): Int
  transcripts(where: TranscriptWhereInput! = {}, orderBy: [TranscriptOrderByInput!]! = [], take: Int, skip: Int! = 0, cursor: TranscriptWhereUniqueInput): [Transcript!]
  transcriptsCount(where: TranscriptWhereInput! = {}): Int
  chats(where: ChatWhereInput! = {}, orderBy: [ChatOrderByInput!]! = [], take: Int, skip: Int! = 0, cursor: ChatWhereUniqueInput): [Chat!]
  chatsCount(where: ChatWhereInput! = {}): Int
}

input OrganizationWhereUniqueInput {
  id: ID
}

input OrganizationWhereInput {
  AND: [OrganizationWhereInput!]
  OR: [OrganizationWhereInput!]
  NOT: [OrganizationWhereInput!]
  id: IDFilter
  name: StringFilter
  users: UserManyRelationFilter
  projects: ProjectManyRelationFilter
  transcripts: TranscriptManyRelationFilter
  chats: ChatManyRelationFilter
}

input UserManyRelationFilter {
  every: UserWhereInput
  some: UserWhereInput
  none: UserWhereInput
}

input ProjectManyRelationFilter {
  every: ProjectWhereInput
  some: ProjectWhereInput
  none: ProjectWhereInput
}

input TranscriptManyRelationFilter {
  every: TranscriptWhereInput
  some: TranscriptWhereInput
  none: TranscriptWhereInput
}

input ChatManyRelationFilter {
  every: ChatWhereInput
  some: ChatWhereInput
  none: ChatWhereInput
}

input OrganizationOrderByInput {
  id: OrderDirection
  name: OrderDirection
}

input OrganizationUpdateInput {
  name: String
  autojoinDomains: JSON
  users: UserRelateToManyForUpdateInput
  projects: ProjectRelateToManyForUpdateInput
  transcripts: TranscriptRelateToManyForUpdateInput
  chats: ChatRelateToManyForUpdateInput
}

input UserRelateToManyForUpdateInput {
  disconnect: [UserWhereUniqueInput!]
  set: [UserWhereUniqueInput!]
  create: [UserCreateInput!]
  connect: [UserWhereUniqueInput!]
}

input ProjectRelateToManyForUpdateInput {
  disconnect: [ProjectWhereUniqueInput!]
  set: [ProjectWhereUniqueInput!]
  create: [ProjectCreateInput!]
  connect: [ProjectWhereUniqueInput!]
}

input TranscriptRelateToManyForUpdateInput {
  disconnect: [TranscriptWhereUniqueInput!]
  set: [TranscriptWhereUniqueInput!]
  create: [TranscriptCreateInput!]
  connect: [TranscriptWhereUniqueInput!]
}

input ChatRelateToManyForUpdateInput {
  disconnect: [ChatWhereUniqueInput!]
  set: [ChatWhereUniqueInput!]
  create: [ChatCreateInput!]
  connect: [ChatWhereUniqueInput!]
}

input OrganizationUpdateArgs {
  where: OrganizationWhereUniqueInput!
  data: OrganizationUpdateInput!
}

input OrganizationCreateInput {
  name: String
  autojoinDomains: JSON
  users: UserRelateToManyForCreateInput
  projects: ProjectRelateToManyForCreateInput
  transcripts: TranscriptRelateToManyForCreateInput
  chats: ChatRelateToManyForCreateInput
}

input UserRelateToManyForCreateInput {
  create: [UserCreateInput!]
  connect: [UserWhereUniqueInput!]
}

input ProjectRelateToManyForCreateInput {
  create: [ProjectCreateInput!]
  connect: [ProjectWhereUniqueInput!]
}

input TranscriptRelateToManyForCreateInput {
  create: [TranscriptCreateInput!]
  connect: [TranscriptWhereUniqueInput!]
}

input ChatRelateToManyForCreateInput {
  create: [ChatCreateInput!]
  connect: [ChatWhereUniqueInput!]
}

type Project {
  id: ID!
  name: String
  description: String
  org: Organization
  transcripts(where: TranscriptWhereInput! = {}, orderBy: [TranscriptOrderByInput!]! = [], take: Int, skip: Int! = 0, cursor: TranscriptWhereUniqueInput): [Transcript!]
  transcriptsCount(where: TranscriptWhereInput! = {}): Int
  chats(where: ChatWhereInput! = {}, orderBy: [ChatOrderByInput!]! = [], take: Int, skip: Int! = 0, cursor: ChatWhereUniqueInput): [Chat!]
  chatsCount(where: ChatWhereInput! = {}): Int
}

input ProjectWhereUniqueInput {
  id: ID
}

input ProjectWhereInput {
  AND: [ProjectWhereInput!]
  OR: [ProjectWhereInput!]
  NOT: [ProjectWhereInput!]
  id: IDFilter
  name: StringFilter
  description: StringFilter
  org: OrganizationWhereInput
  transcripts: TranscriptManyRelationFilter
  chats: ChatManyRelationFilter
}

input ProjectOrderByInput {
  id: OrderDirection
  name: OrderDirection
  description: OrderDirection
}

input ProjectUpdateInput {
  name: String
  description: String
  org: OrganizationRelateToOneForUpdateInput
  transcripts: TranscriptRelateToManyForUpdateInput
  chats: ChatRelateToManyForUpdateInput
}

input ProjectUpdateArgs {
  where: ProjectWhereUniqueInput!
  data: ProjectUpdateInput!
}

input ProjectCreateInput {
  name: String
  description: String
  org: OrganizationRelateToOneForCreateInput
  transcripts: TranscriptRelateToManyForCreateInput
  chats: ChatRelateToManyForCreateInput
}

type Transcript {
  id: ID!
  title: String
  intervieweeName: String
  sourceUrl: String
  language: String
  notes: String
  project: Project
  org: Organization
  segments(where: TranscriptSegmentWhereInput! = {}, orderBy: [TranscriptSegmentOrderByInput!]! = [], take: Int, skip: Int! = 0, cursor: TranscriptSegmentWhereUniqueInput): [TranscriptSegment!]
  segmentsCount(where: TranscriptSegmentWhereInput! = {}): Int
  chats(where: ChatWhereInput! = {}, orderBy: [ChatOrderByInput!]! = [], take: Int, skip: Int! = 0, cursor: ChatWhereUniqueInput): [Chat!]
  chatsCount(where: ChatWhereInput! = {}): Int
  createdAt: DateTime
  updatedAt: DateTime
}

input TranscriptWhereUniqueInput {
  id: ID
}

input TranscriptWhereInput {
  AND: [TranscriptWhereInput!]
  OR: [TranscriptWhereInput!]
  NOT: [TranscriptWhereInput!]
  id: IDFilter
  title: StringFilter
  intervieweeName: StringFilter
  sourceUrl: StringFilter
  language: StringFilter
  notes: StringFilter
  project: ProjectWhereInput
  org: OrganizationWhereInput
  segments: TranscriptSegmentManyRelationFilter
  chats: ChatManyRelationFilter
  createdAt: DateTimeNullableFilter
  updatedAt: DateTimeNullableFilter
}

input TranscriptOrderByInput {
  id: OrderDirection
  title: OrderDirection
  intervieweeName: OrderDirection
  sourceUrl: OrderDirection
  language: OrderDirection
  notes: OrderDirection
  createdAt: OrderDirection
  updatedAt: OrderDirection
}

input TranscriptUpdateInput {
  title: String
  intervieweeName: String
  sourceUrl: String
  language: String
  notes: String
  project: ProjectRelateToOneForUpdateInput
  org: OrganizationRelateToOneForUpdateInput
  segments: TranscriptSegmentRelateToManyForUpdateInput
  chats: ChatRelateToManyForUpdateInput
  createdAt: DateTime
  updatedAt: DateTime
}

input TranscriptUpdateArgs {
  where: TranscriptWhereUniqueInput!
  data: TranscriptUpdateInput!
}

input TranscriptCreateInput {
  title: String
  intervieweeName: String
  sourceUrl: String
  language: String
  notes: String
  project: ProjectRelateToOneForCreateInput
  org: OrganizationRelateToOneForCreateInput
  segments: TranscriptSegmentRelateToManyForCreateInput
  chats: ChatRelateToManyForCreateInput
  createdAt: DateTime
  updatedAt: DateTime
}

type TranscriptSegment {
  id: ID!
  transcript: Transcript
  index: Int
  startMs: Int
  endMs: Int
  durationMs: Int
  text: String
  speaker: String
  isMetadata: Boolean
  chatMessages(where: ChatMessageWhereInput! = {}, orderBy: [ChatMessageOrderByInput!]! = [], take: Int, skip: Int! = 0, cursor: ChatMessageWhereUniqueInput): [ChatMessage!]
  chatMessagesCount(where: ChatMessageWhereInput! = {}): Int
}

input TranscriptSegmentWhereUniqueInput {
  id: ID
}

input TranscriptSegmentWhereInput {
  AND: [TranscriptSegmentWhereInput!]
  OR: [TranscriptSegmentWhereInput!]
  NOT: [TranscriptSegmentWhereInput!]
  id: IDFilter
  transcript: TranscriptWhereInput
  index: IntNullableFilter
  startMs: IntNullableFilter
  endMs: IntNullableFilter
  durationMs: IntNullableFilter
  text: StringFilter
  speaker: StringFilter
  isMetadata: BooleanFilter
  chatMessages: ChatMessageManyRelationFilter
}

input IntNullableFilter {
  equals: Int
  in: [Int!]
  notIn: [Int!]
  lt: Int
  lte: Int
  gt: Int
  gte: Int
  not: IntNullableFilter
}

input BooleanFilter {
  equals: Boolean
  not: BooleanFilter
}

input TranscriptSegmentOrderByInput {
  id: OrderDirection
  index: OrderDirection
  startMs: OrderDirection
  endMs: OrderDirection
  durationMs: OrderDirection
  text: OrderDirection
  speaker: OrderDirection
  isMetadata: OrderDirection
}

input TranscriptSegmentUpdateInput {
  transcript: TranscriptRelateToOneForUpdateInput
  index: Int
  startMs: Int
  endMs: Int
  durationMs: Int
  text: String
  speaker: String
  isMetadata: Boolean
  chatMessages: ChatMessageRelateToManyForUpdateInput
}

input TranscriptSegmentUpdateArgs {
  where: TranscriptSegmentWhereUniqueInput!
  data: TranscriptSegmentUpdateInput!
}

input TranscriptSegmentCreateInput {
  transcript: TranscriptRelateToOneForCreateInput
  index: Int
  startMs: Int
  endMs: Int
  durationMs: Int
  text: String
  speaker: String
  isMetadata: Boolean
  chatMessages: ChatMessageRelateToManyForCreateInput
}

type User {
  id: ID!
  avatarSocialUrl: String
  avatarUploaded: CloudinaryImage_File
  avatarUrl: String
  email: String
  firstName: String
  lastName: String
  displayName: String
  role: UserRoleType
  providerAccountId: String
  provider: UserProviderType
  rawAuth: JSON
  org: Organization
  isActive: Boolean
  createdAt: DateTime
  provisionedAt: DateTime
  updatedAt: DateTime
  seenAt: DateTime
}

type CloudinaryImage_File {
  id: ID
  filename: String
  originalFilename: String
  mimetype: String
  encoding: String
  publicUrl: String
  publicUrlTransformed(transformation: CloudinaryImageFormat): String
}

"""
Mirrors the formatting options [Cloudinary provides](https://cloudinary.com/documentation/image_transformation_reference).
All options are strings as they ultimately end up in a URL.
"""
input CloudinaryImageFormat {
  """ Rewrites the filename to be this pretty string. Do not include `/` or `.`
  """
  prettyName: String
  width: String
  height: String
  crop: String
  aspect_ratio: String
  gravity: String
  zoom: String
  x: String
  y: String
  format: String
  fetch_format: String
  quality: String
  radius: String
  angle: String
  effect: String
  opacity: String
  border: String
  background: String
  overlay: String
  underlay: String
  default_image: String
  delay: String
  color: String
  color_space: String
  dpr: String
  page: String
  density: String
  flags: String
  transformation: String
}

enum UserRoleType {
  USER
  ORG_ADMIN
  ORG_OWNER
  GOD
}

enum UserProviderType {
  google
}

input UserWhereUniqueInput {
  id: ID
  providerAccountId: String
}

input UserWhereInput {
  AND: [UserWhereInput!]
  OR: [UserWhereInput!]
  NOT: [UserWhereInput!]
  id: IDFilter
  avatarSocialUrl: StringFilter
  email: StringFilter
  firstName: StringFilter
  lastName: StringFilter
  role: UserRoleTypeNullableFilter
  providerAccountId: StringFilter
  provider: UserProviderTypeNullableFilter
  org: OrganizationWhereInput
  isActive: BooleanFilter
  createdAt: DateTimeNullableFilter
  provisionedAt: DateTimeNullableFilter
  updatedAt: DateTimeNullableFilter
  seenAt: DateTimeNullableFilter
}

input UserRoleTypeNullableFilter {
  equals: UserRoleType
  in: [UserRoleType!]
  notIn: [UserRoleType!]
  not: UserRoleTypeNullableFilter
}

input UserProviderTypeNullableFilter {
  equals: UserProviderType
  in: [UserProviderType!]
  notIn: [UserProviderType!]
  not: UserProviderTypeNullableFilter
}

input UserOrderByInput {
  id: OrderDirection
  avatarSocialUrl: OrderDirection
  email: OrderDirection
  firstName: OrderDirection
  lastName: OrderDirection
  role: OrderDirection
  providerAccountId: OrderDirection
  provider: OrderDirection
  isActive: OrderDirection
  createdAt: OrderDirection
  provisionedAt: OrderDirection
  updatedAt: OrderDirection
  seenAt: OrderDirection
}

input UserUpdateInput {
  avatarSocialUrl: String
  avatarUploaded: Upload
  email: String
  firstName: String
  lastName: String
  role: UserRoleType
  providerAccountId: String
  provider: UserProviderType
  rawAuth: JSON
  org: OrganizationRelateToOneForUpdateInput
  isActive: Boolean
  createdAt: DateTime
  provisionedAt: DateTime
  updatedAt: DateTime
  seenAt: DateTime
}

"""The `Upload` scalar type represents a file upload."""
scalar Upload

input UserUpdateArgs {
  where: UserWhereUniqueInput!
  data: UserUpdateInput!
}

input UserCreateInput {
  avatarSocialUrl: String
  avatarUploaded: Upload
  email: String
  firstName: String
  lastName: String
  role: UserRoleType
  providerAccountId: String
  provider: UserProviderType
  rawAuth: JSON
  org: OrganizationRelateToOneForCreateInput
  isActive: Boolean
  createdAt: DateTime
  provisionedAt: DateTime
  updatedAt: DateTime
  seenAt: DateTime
}

"""
The `JSON` scalar type represents JSON values as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
"""
scalar JSON @specifiedBy(url: "http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf")

type Mutation {
  createChat(data: ChatCreateInput!): Chat
  createChats(data: [ChatCreateInput!]!): [Chat]
  updateChat(where: ChatWhereUniqueInput!, data: ChatUpdateInput!): Chat
  updateChats(data: [ChatUpdateArgs!]!): [Chat]
  deleteChat(where: ChatWhereUniqueInput!): Chat
  deleteChats(where: [ChatWhereUniqueInput!]!): [Chat]
  createChatMessage(data: ChatMessageCreateInput!): ChatMessage
  createChatMessages(data: [ChatMessageCreateInput!]!): [ChatMessage]
  updateChatMessage(where: ChatMessageWhereUniqueInput!, data: ChatMessageUpdateInput!): ChatMessage
  updateChatMessages(data: [ChatMessageUpdateArgs!]!): [ChatMessage]
  deleteChatMessage(where: ChatMessageWhereUniqueInput!): ChatMessage
  deleteChatMessages(where: [ChatMessageWhereUniqueInput!]!): [ChatMessage]
  createOrganization(data: OrganizationCreateInput!): Organization
  createOrganizations(data: [OrganizationCreateInput!]!): [Organization]
  updateOrganization(where: OrganizationWhereUniqueInput!, data: OrganizationUpdateInput!): Organization
  updateOrganizations(data: [OrganizationUpdateArgs!]!): [Organization]
  deleteOrganization(where: OrganizationWhereUniqueInput!): Organization
  deleteOrganizations(where: [OrganizationWhereUniqueInput!]!): [Organization]
  createProject(data: ProjectCreateInput!): Project
  createProjects(data: [ProjectCreateInput!]!): [Project]
  updateProject(where: ProjectWhereUniqueInput!, data: ProjectUpdateInput!): Project
  updateProjects(data: [ProjectUpdateArgs!]!): [Project]
  deleteProject(where: ProjectWhereUniqueInput!): Project
  deleteProjects(where: [ProjectWhereUniqueInput!]!): [Project]
  createTranscript(data: TranscriptCreateInput!): Transcript
  createTranscripts(data: [TranscriptCreateInput!]!): [Transcript]
  updateTranscript(where: TranscriptWhereUniqueInput!, data: TranscriptUpdateInput!): Transcript
  updateTranscripts(data: [TranscriptUpdateArgs!]!): [Transcript]
  deleteTranscript(where: TranscriptWhereUniqueInput!): Transcript
  deleteTranscripts(where: [TranscriptWhereUniqueInput!]!): [Transcript]
  createTranscriptSegment(data: TranscriptSegmentCreateInput!): TranscriptSegment
  createTranscriptSegments(data: [TranscriptSegmentCreateInput!]!): [TranscriptSegment]
  updateTranscriptSegment(where: TranscriptSegmentWhereUniqueInput!, data: TranscriptSegmentUpdateInput!): TranscriptSegment
  updateTranscriptSegments(data: [TranscriptSegmentUpdateArgs!]!): [TranscriptSegment]
  deleteTranscriptSegment(where: TranscriptSegmentWhereUniqueInput!): TranscriptSegment
  deleteTranscriptSegments(where: [TranscriptSegmentWhereUniqueInput!]!): [TranscriptSegment]
  createUser(data: UserCreateInput!): User
  createUsers(data: [UserCreateInput!]!): [User]
  updateUser(where: UserWhereUniqueInput!, data: UserUpdateInput!): User
  updateUsers(data: [UserUpdateArgs!]!): [User]
  deleteUser(where: UserWhereUniqueInput!): User
  deleteUsers(where: [UserWhereUniqueInput!]!): [User]
  endSession: Boolean!
  ingestTranscript(input: IngestTranscriptInput!): IngestTranscriptResult!
  chatTranscript(input: ChatTranscriptInput!): ChatMutationResult!
  chatProject(input: ChatProjectInput!): ChatMutationResult!
}

type IngestTranscriptResult {
  transcriptId: ID!
  segmentsCount: Int!
  projectId: ID!
}

input IngestTranscriptInput {
  projectId: ID!
  title: String!
  intervieweeName: String
  sourceUrl: String
  language: String
  notes: String
  srt: String!
}

type ChatMutationResult {
  chatId: ID!
  answer: String!
  messages: [ChatMessageResult!]!
  references: [ChatSegmentReference!]!
}

type ChatMessageResult {
  id: ID!
  role: String!
  content: String!
  createdAt: String
  segments: [ChatSegmentReference!]!
}

type ChatSegmentReference {
  id: ID!
  text: String!
  startMs: Int
  endMs: Int
  speaker: String
  transcriptTitle: String
}

input ChatTranscriptInput {
  chatId: ID
  transcriptId: ID!
  message: String!
}

input ChatProjectInput {
  chatId: ID
  projectId: ID!
  message: String!
}

type Query {
  chat(where: ChatWhereUniqueInput!): Chat
  chats(where: ChatWhereInput! = {}, orderBy: [ChatOrderByInput!]! = [], take: Int, skip: Int! = 0, cursor: ChatWhereUniqueInput): [Chat!]
  chatsCount(where: ChatWhereInput! = {}): Int
  chatMessage(where: ChatMessageWhereUniqueInput!): ChatMessage
  chatMessages(where: ChatMessageWhereInput! = {}, orderBy: [ChatMessageOrderByInput!]! = [], take: Int, skip: Int! = 0, cursor: ChatMessageWhereUniqueInput): [ChatMessage!]
  chatMessagesCount(where: ChatMessageWhereInput! = {}): Int
  organization(where: OrganizationWhereUniqueInput!): Organization
  organizations(where: OrganizationWhereInput! = {}, orderBy: [OrganizationOrderByInput!]! = [], take: Int, skip: Int! = 0, cursor: OrganizationWhereUniqueInput): [Organization!]
  organizationsCount(where: OrganizationWhereInput! = {}): Int
  project(where: ProjectWhereUniqueInput!): Project
  projects(where: ProjectWhereInput! = {}, orderBy: [ProjectOrderByInput!]! = [], take: Int, skip: Int! = 0, cursor: ProjectWhereUniqueInput): [Project!]
  projectsCount(where: ProjectWhereInput! = {}): Int
  transcript(where: TranscriptWhereUniqueInput!): Transcript
  transcripts(where: TranscriptWhereInput! = {}, orderBy: [TranscriptOrderByInput!]! = [], take: Int, skip: Int! = 0, cursor: TranscriptWhereUniqueInput): [Transcript!]
  transcriptsCount(where: TranscriptWhereInput! = {}): Int
  transcriptSegment(where: TranscriptSegmentWhereUniqueInput!): TranscriptSegment
  transcriptSegments(where: TranscriptSegmentWhereInput! = {}, orderBy: [TranscriptSegmentOrderByInput!]! = [], take: Int, skip: Int! = 0, cursor: TranscriptSegmentWhereUniqueInput): [TranscriptSegment!]
  transcriptSegmentsCount(where: TranscriptSegmentWhereInput! = {}): Int
  user(where: UserWhereUniqueInput!): User
  users(where: UserWhereInput! = {}, orderBy: [UserOrderByInput!]! = [], take: Int, skip: Int! = 0, cursor: UserWhereUniqueInput): [User!]
  usersCount(where: UserWhereInput! = {}): Int
  keystone: KeystoneMeta!
  chatTranscriptHistory(transcriptId: ID!, chatId: ID): ChatHistoryResult!
  chatProjectHistory(projectId: ID!, chatId: ID): ChatHistoryResult!
}

type ChatHistoryResult {
  chatId: ID
  messages: [ChatMessageResult!]!
}

type KeystoneMeta {
  adminMeta: KeystoneAdminMeta!
}

type KeystoneAdminMeta {
  lists: [KeystoneAdminUIListMeta!]!
  list(key: String!): KeystoneAdminUIListMeta
}

type KeystoneAdminUIListMeta {
  key: String!
  path: String!
  label: String!
  singular: String!
  plural: String!
  description: String
  pageSize: Int!
  labelField: String!
  fields: [KeystoneAdminUIFieldMeta!]!
  groups: [KeystoneAdminUIFieldGroupMeta!]!
  graphql: KeystoneAdminUIGraphQL!
  initialColumns: [String!]!
  initialSearchFields: [String!]!
  initialSort: KeystoneAdminUISort
  isSingleton: Boolean!
  hideCreate: Boolean!
  hideDelete: Boolean!
  isHidden: Boolean!
  itemQueryName: String!
  listQueryName: String!
}

type KeystoneAdminUIFieldMeta {
  path: String!
  label: String!
  description: String
  isOrderable: Boolean!
  isFilterable: Boolean!
  isNonNull: [KeystoneAdminUIFieldMetaIsNonNull!]
  fieldMeta: JSON
  viewsIndex: Int!
  customViewsIndex: Int
  createView: KeystoneAdminUIFieldMetaCreateView!
  listView: KeystoneAdminUIFieldMetaListView!
  itemView(id: ID): KeystoneAdminUIFieldMetaItemView
  search: QueryMode
}

enum KeystoneAdminUIFieldMetaIsNonNull {
  read
  create
  update
}

type KeystoneAdminUIFieldMetaCreateView {
  fieldMode: KeystoneAdminUIFieldMetaCreateViewFieldMode!
}

enum KeystoneAdminUIFieldMetaCreateViewFieldMode {
  edit
  hidden
}

type KeystoneAdminUIFieldMetaListView {
  fieldMode: KeystoneAdminUIFieldMetaListViewFieldMode!
}

enum KeystoneAdminUIFieldMetaListViewFieldMode {
  read
  hidden
}

type KeystoneAdminUIFieldMetaItemView {
  fieldMode: KeystoneAdminUIFieldMetaItemViewFieldMode
  fieldPosition: KeystoneAdminUIFieldMetaItemViewFieldPosition
}

enum KeystoneAdminUIFieldMetaItemViewFieldMode {
  edit
  read
  hidden
}

enum KeystoneAdminUIFieldMetaItemViewFieldPosition {
  form
  sidebar
}

type KeystoneAdminUIFieldGroupMeta {
  label: String!
  description: String
  fields: [KeystoneAdminUIFieldMeta!]!
}

type KeystoneAdminUIGraphQL {
  names: KeystoneAdminUIGraphQLNames!
}

type KeystoneAdminUIGraphQLNames {
  outputTypeName: String!
  whereInputName: String!
  whereUniqueInputName: String!
  createInputName: String!
  createMutationName: String!
  createManyMutationName: String!
  relateToOneForCreateInputName: String!
  relateToManyForCreateInputName: String!
  itemQueryName: String!
  listOrderName: String!
  listQueryCountName: String!
  listQueryName: String!
  updateInputName: String!
  updateMutationName: String!
  updateManyInputName: String!
  updateManyMutationName: String!
  relateToOneForUpdateInputName: String!
  relateToManyForUpdateInputName: String!
  deleteMutationName: String!
  deleteManyMutationName: String!
}

type KeystoneAdminUISort {
  field: String!
  direction: KeystoneAdminUISortDirection!
}

enum KeystoneAdminUISortDirection {
  ASC
  DESC
}
