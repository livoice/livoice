# This file is automatically generated by Keystone, do not modify it manually.
# Modify your Keystone config when you want to change this.

type Chat {
  id: ID!
  title: String
  systemPrompt: String
  config: JSON
  user: User
  org: Organization
  project: Project
  messages(where: ChatMessageWhereInput! = {}, orderBy: [ChatMessageOrderByInput!]! = [], take: Int, skip: Int! = 0, cursor: ChatMessageWhereUniqueInput): [ChatMessage!]
  messagesCount(where: ChatMessageWhereInput! = {}): Int
  createdAt: DateTime
  updatedAt: DateTime
}

scalar DateTime @specifiedBy(url: "https://datatracker.ietf.org/doc/html/rfc3339#section-5.6")

input ChatWhereUniqueInput {
  id: ID
}

input ChatWhereInput {
  AND: [ChatWhereInput!]
  OR: [ChatWhereInput!]
  NOT: [ChatWhereInput!]
  id: IDFilter
  title: StringFilter
  systemPrompt: StringFilter
  user: UserWhereInput
  org: OrganizationWhereInput
  project: ProjectWhereInput
  messages: ChatMessageManyRelationFilter
  createdAt: DateTimeNullableFilter
  updatedAt: DateTimeNullableFilter
}

input IDFilter {
  equals: ID
  in: [ID!]
  notIn: [ID!]
  lt: ID
  lte: ID
  gt: ID
  gte: ID
  not: IDFilter
}

input StringFilter {
  equals: String
  in: [String!]
  notIn: [String!]
  lt: String
  lte: String
  gt: String
  gte: String
  contains: String
  startsWith: String
  endsWith: String
  mode: QueryMode
  not: NestedStringFilter
}

enum QueryMode {
  default
  insensitive
}

input NestedStringFilter {
  equals: String
  in: [String!]
  notIn: [String!]
  lt: String
  lte: String
  gt: String
  gte: String
  contains: String
  startsWith: String
  endsWith: String
  not: NestedStringFilter
}

input ChatMessageManyRelationFilter {
  every: ChatMessageWhereInput
  some: ChatMessageWhereInput
  none: ChatMessageWhereInput
}

input DateTimeNullableFilter {
  equals: DateTime
  in: [DateTime!]
  notIn: [DateTime!]
  lt: DateTime
  lte: DateTime
  gt: DateTime
  gte: DateTime
  not: DateTimeNullableFilter
}

input ChatOrderByInput {
  id: OrderDirection
  title: OrderDirection
  systemPrompt: OrderDirection
  createdAt: OrderDirection
  updatedAt: OrderDirection
}

enum OrderDirection {
  asc
  desc
}

input ChatUpdateInput {
  title: String
  systemPrompt: String
  config: JSON
  user: UserRelateToOneForUpdateInput
  org: OrganizationRelateToOneForUpdateInput
  project: ProjectRelateToOneForUpdateInput
  messages: ChatMessageRelateToManyForUpdateInput
  createdAt: DateTime
  updatedAt: DateTime
}

input UserRelateToOneForUpdateInput {
  create: UserCreateInput
  connect: UserWhereUniqueInput
  disconnect: Boolean
}

input OrganizationRelateToOneForUpdateInput {
  create: OrganizationCreateInput
  connect: OrganizationWhereUniqueInput
  disconnect: Boolean
}

input ProjectRelateToOneForUpdateInput {
  create: ProjectCreateInput
  connect: ProjectWhereUniqueInput
  disconnect: Boolean
}

input ChatMessageRelateToManyForUpdateInput {
  disconnect: [ChatMessageWhereUniqueInput!]
  set: [ChatMessageWhereUniqueInput!]
  create: [ChatMessageCreateInput!]
  connect: [ChatMessageWhereUniqueInput!]
}

input ChatUpdateArgs {
  where: ChatWhereUniqueInput!
  data: ChatUpdateInput!
}

input ChatCreateInput {
  title: String
  systemPrompt: String
  config: JSON
  user: UserRelateToOneForCreateInput
  org: OrganizationRelateToOneForCreateInput
  project: ProjectRelateToOneForCreateInput
  messages: ChatMessageRelateToManyForCreateInput
  createdAt: DateTime
  updatedAt: DateTime
}

input UserRelateToOneForCreateInput {
  create: UserCreateInput
  connect: UserWhereUniqueInput
}

input OrganizationRelateToOneForCreateInput {
  create: OrganizationCreateInput
  connect: OrganizationWhereUniqueInput
}

input ProjectRelateToOneForCreateInput {
  create: ProjectCreateInput
  connect: ProjectWhereUniqueInput
}

input ChatMessageRelateToManyForCreateInput {
  create: [ChatMessageCreateInput!]
  connect: [ChatMessageWhereUniqueInput!]
}

type ChatMessage {
  id: ID!
  chat: Chat
  role: String
  content: String
  debugData: JSON
  createdAt: DateTime
}

input ChatMessageWhereUniqueInput {
  id: ID
}

input ChatMessageWhereInput {
  AND: [ChatMessageWhereInput!]
  OR: [ChatMessageWhereInput!]
  NOT: [ChatMessageWhereInput!]
  id: IDFilter
  chat: ChatWhereInput
  role: StringFilter
  content: StringFilter
  createdAt: DateTimeNullableFilter
}

input ChatMessageOrderByInput {
  id: OrderDirection
  role: OrderDirection
  content: OrderDirection
  createdAt: OrderDirection
}

input ChatMessageUpdateInput {
  chat: ChatRelateToOneForUpdateInput
  role: String
  content: String
  debugData: JSON
  createdAt: DateTime
}

input ChatRelateToOneForUpdateInput {
  create: ChatCreateInput
  connect: ChatWhereUniqueInput
  disconnect: Boolean
}

input ChatMessageUpdateArgs {
  where: ChatMessageWhereUniqueInput!
  data: ChatMessageUpdateInput!
}

input ChatMessageCreateInput {
  chat: ChatRelateToOneForCreateInput
  role: String
  content: String
  debugData: JSON
  createdAt: DateTime
}

input ChatRelateToOneForCreateInput {
  create: ChatCreateInput
  connect: ChatWhereUniqueInput
}

type Organization {
  id: ID!
  name: String
  autojoinDomains: JSON
  users(where: UserWhereInput! = {}, orderBy: [UserOrderByInput!]! = [], take: Int, skip: Int! = 0, cursor: UserWhereUniqueInput): [User!]
  usersCount(where: UserWhereInput! = {}): Int
  projects(where: ProjectWhereInput! = {}, orderBy: [ProjectOrderByInput!]! = [], take: Int, skip: Int! = 0, cursor: ProjectWhereUniqueInput): [Project!]
  projectsCount(where: ProjectWhereInput! = {}): Int
  transcripts(where: TranscriptWhereInput! = {}, orderBy: [TranscriptOrderByInput!]! = [], take: Int, skip: Int! = 0, cursor: TranscriptWhereUniqueInput): [Transcript!]
  transcriptsCount(where: TranscriptWhereInput! = {}): Int
  sources(where: SourceWhereInput! = {}, orderBy: [SourceOrderByInput!]! = [], take: Int, skip: Int! = 0, cursor: SourceWhereUniqueInput): [Source!]
  sourcesCount(where: SourceWhereInput! = {}): Int
  chats(where: ChatWhereInput! = {}, orderBy: [ChatOrderByInput!]! = [], take: Int, skip: Int! = 0, cursor: ChatWhereUniqueInput): [Chat!]
  chatsCount(where: ChatWhereInput! = {}): Int
}

input OrganizationWhereUniqueInput {
  id: ID
}

input OrganizationWhereInput {
  AND: [OrganizationWhereInput!]
  OR: [OrganizationWhereInput!]
  NOT: [OrganizationWhereInput!]
  id: IDFilter
  name: StringFilter
  users: UserManyRelationFilter
  projects: ProjectManyRelationFilter
  transcripts: TranscriptManyRelationFilter
  sources: SourceManyRelationFilter
  chats: ChatManyRelationFilter
}

input UserManyRelationFilter {
  every: UserWhereInput
  some: UserWhereInput
  none: UserWhereInput
}

input ProjectManyRelationFilter {
  every: ProjectWhereInput
  some: ProjectWhereInput
  none: ProjectWhereInput
}

input TranscriptManyRelationFilter {
  every: TranscriptWhereInput
  some: TranscriptWhereInput
  none: TranscriptWhereInput
}

input SourceManyRelationFilter {
  every: SourceWhereInput
  some: SourceWhereInput
  none: SourceWhereInput
}

input ChatManyRelationFilter {
  every: ChatWhereInput
  some: ChatWhereInput
  none: ChatWhereInput
}

input OrganizationOrderByInput {
  id: OrderDirection
  name: OrderDirection
}

input OrganizationUpdateInput {
  name: String
  autojoinDomains: JSON
  users: UserRelateToManyForUpdateInput
  projects: ProjectRelateToManyForUpdateInput
  transcripts: TranscriptRelateToManyForUpdateInput
  sources: SourceRelateToManyForUpdateInput
  chats: ChatRelateToManyForUpdateInput
}

input UserRelateToManyForUpdateInput {
  disconnect: [UserWhereUniqueInput!]
  set: [UserWhereUniqueInput!]
  create: [UserCreateInput!]
  connect: [UserWhereUniqueInput!]
}

input ProjectRelateToManyForUpdateInput {
  disconnect: [ProjectWhereUniqueInput!]
  set: [ProjectWhereUniqueInput!]
  create: [ProjectCreateInput!]
  connect: [ProjectWhereUniqueInput!]
}

input TranscriptRelateToManyForUpdateInput {
  disconnect: [TranscriptWhereUniqueInput!]
  set: [TranscriptWhereUniqueInput!]
  create: [TranscriptCreateInput!]
  connect: [TranscriptWhereUniqueInput!]
}

input SourceRelateToManyForUpdateInput {
  disconnect: [SourceWhereUniqueInput!]
  set: [SourceWhereUniqueInput!]
  create: [SourceCreateInput!]
  connect: [SourceWhereUniqueInput!]
}

input ChatRelateToManyForUpdateInput {
  disconnect: [ChatWhereUniqueInput!]
  set: [ChatWhereUniqueInput!]
  create: [ChatCreateInput!]
  connect: [ChatWhereUniqueInput!]
}

input OrganizationUpdateArgs {
  where: OrganizationWhereUniqueInput!
  data: OrganizationUpdateInput!
}

input OrganizationCreateInput {
  name: String
  autojoinDomains: JSON
  users: UserRelateToManyForCreateInput
  projects: ProjectRelateToManyForCreateInput
  transcripts: TranscriptRelateToManyForCreateInput
  sources: SourceRelateToManyForCreateInput
  chats: ChatRelateToManyForCreateInput
}

input UserRelateToManyForCreateInput {
  create: [UserCreateInput!]
  connect: [UserWhereUniqueInput!]
}

input ProjectRelateToManyForCreateInput {
  create: [ProjectCreateInput!]
  connect: [ProjectWhereUniqueInput!]
}

input TranscriptRelateToManyForCreateInput {
  create: [TranscriptCreateInput!]
  connect: [TranscriptWhereUniqueInput!]
}

input SourceRelateToManyForCreateInput {
  create: [SourceCreateInput!]
  connect: [SourceWhereUniqueInput!]
}

input ChatRelateToManyForCreateInput {
  create: [ChatCreateInput!]
  connect: [ChatWhereUniqueInput!]
}

type Project {
  id: ID!
  name: String
  description: String
  org: Organization
  sources(where: SourceWhereInput! = {}, orderBy: [SourceOrderByInput!]! = [], take: Int, skip: Int! = 0, cursor: SourceWhereUniqueInput): [Source!]
  sourcesCount(where: SourceWhereInput! = {}): Int
  chats(where: ChatWhereInput! = {}, orderBy: [ChatOrderByInput!]! = [], take: Int, skip: Int! = 0, cursor: ChatWhereUniqueInput): [Chat!]
  chatsCount(where: ChatWhereInput! = {}): Int
}

input ProjectWhereUniqueInput {
  id: ID
}

input ProjectWhereInput {
  AND: [ProjectWhereInput!]
  OR: [ProjectWhereInput!]
  NOT: [ProjectWhereInput!]
  id: IDFilter
  name: StringFilter
  description: StringFilter
  org: OrganizationWhereInput
  sources: SourceManyRelationFilter
  chats: ChatManyRelationFilter
}

input ProjectOrderByInput {
  id: OrderDirection
  name: OrderDirection
  description: OrderDirection
}

input ProjectUpdateInput {
  name: String
  description: String
  org: OrganizationRelateToOneForUpdateInput
  sources: SourceRelateToManyForUpdateInput
  chats: ChatRelateToManyForUpdateInput
}

input ProjectUpdateArgs {
  where: ProjectWhereUniqueInput!
  data: ProjectUpdateInput!
}

input ProjectCreateInput {
  name: String
  description: String
  org: OrganizationRelateToOneForCreateInput
  sources: SourceRelateToManyForCreateInput
  chats: ChatRelateToManyForCreateInput
}

type Source {
  id: ID!
  type: SourceTypeType
  name: String
  url: String
  externalId: String
  importStatus: SourceImportStatusType
  importStartedAt: DateTime
  importCompletedAt: DateTime
  importCronExpression: String
  importNextAt: DateTime
  importHistory: JSON
  importHistoryTyped: [ImportHistoryEntry]
  transcriptImportProgress: TranscriptImportProgress
  transcriptEmbeddingProgress: TranscriptEmbeddingProgress
  overallProgress: OverallProgress
  org: Organization
  transcripts(where: TranscriptWhereInput! = {}, orderBy: [TranscriptOrderByInput!]! = [], take: Int, skip: Int! = 0, cursor: TranscriptWhereUniqueInput): [Transcript!]
  transcriptsCount(where: TranscriptWhereInput! = {}): Int
  projects(where: ProjectWhereInput! = {}, orderBy: [ProjectOrderByInput!]! = [], take: Int, skip: Int! = 0, cursor: ProjectWhereUniqueInput): [Project!]
  projectsCount(where: ProjectWhereInput! = {}): Int
  importTrigger: String
}

enum SourceTypeType {
  youtube_channel
}

enum SourceImportStatusType {
  idle
  importing
  completed
  failed
}

type ImportHistoryEntry {
  startedAt: DateTime
  completedAt: DateTime
  itemsFound: Int
  itemsImported: Int
  itemsSkipped: Int
  itemsFailed: Int
  error: String
}

type TranscriptImportProgress {
  total: Int!
  pending: Int!
  fetching: Int!
  completed: Int!
  failed: Int!
  skipped: Int!
  pendingPercentage: Float!
  fetchingPercentage: Float!
  completedPercentage: Float!
  failedPercentage: Float!
  skippedPercentage: Float!
}

type TranscriptEmbeddingProgress {
  total: Int!
  pending: Int!
  processing: Int!
  completed: Int!
  failed: Int!
  pendingPercentage: Float!
  processingPercentage: Float!
  completedPercentage: Float!
  failedPercentage: Float!
}

type OverallProgress {
  importCompletedPercentage: Float!
  embeddingCompletedPercentage: Float!
  overallPercentage: Float!
}

input SourceWhereUniqueInput {
  id: ID
  externalId: String
}

input SourceWhereInput {
  AND: [SourceWhereInput!]
  OR: [SourceWhereInput!]
  NOT: [SourceWhereInput!]
  id: IDFilter
  type: SourceTypeTypeNullableFilter
  name: StringFilter
  url: StringFilter
  externalId: StringFilter
  importStatus: SourceImportStatusTypeNullableFilter
  importStartedAt: DateTimeNullableFilter
  importCompletedAt: DateTimeNullableFilter
  importCronExpression: StringFilter
  org: OrganizationWhereInput
  transcripts: TranscriptManyRelationFilter
  projects: ProjectManyRelationFilter
}

input SourceTypeTypeNullableFilter {
  equals: SourceTypeType
  in: [SourceTypeType!]
  notIn: [SourceTypeType!]
  not: SourceTypeTypeNullableFilter
}

input SourceImportStatusTypeNullableFilter {
  equals: SourceImportStatusType
  in: [SourceImportStatusType!]
  notIn: [SourceImportStatusType!]
  not: SourceImportStatusTypeNullableFilter
}

input SourceOrderByInput {
  id: OrderDirection
  type: OrderDirection
  name: OrderDirection
  url: OrderDirection
  externalId: OrderDirection
  importStatus: OrderDirection
  importStartedAt: OrderDirection
  importCompletedAt: OrderDirection
  importCronExpression: OrderDirection
}

input SourceUpdateInput {
  type: SourceTypeType
  name: String
  url: String
  externalId: String
  importStatus: SourceImportStatusType
  importStartedAt: DateTime
  importCompletedAt: DateTime
  importCronExpression: String
  importHistory: JSON
  org: OrganizationRelateToOneForUpdateInput
  transcripts: TranscriptRelateToManyForUpdateInput
  projects: ProjectRelateToManyForUpdateInput
}

input SourceUpdateArgs {
  where: SourceWhereUniqueInput!
  data: SourceUpdateInput!
}

input SourceCreateInput {
  type: SourceTypeType
  name: String
  url: String
  externalId: String
  importStatus: SourceImportStatusType
  importStartedAt: DateTime
  importCompletedAt: DateTime
  importCronExpression: String
  importHistory: JSON
  org: OrganizationRelateToOneForCreateInput
  transcripts: TranscriptRelateToManyForCreateInput
  projects: ProjectRelateToManyForCreateInput
}

type Transcript {
  id: ID!
  title: String
  intervieweeName: String
  sourceUrl: String
  language: String
  notes: String
  externalId: String
  publishedAt: DateTime
  duration: Int
  thumbnailUrl: String
  embeddingStatus: TranscriptEmbeddingStatusType
  embeddingAttempts: Int
  embeddingError: String
  embeddingAt: DateTime
  importStatus: TranscriptImportStatusType
  importAttempts: Int
  importError: String
  importAt: DateTime
  source: Source
  org: Organization
  segments(where: TranscriptSegmentWhereInput! = {}, orderBy: [TranscriptSegmentOrderByInput!]! = [], take: Int, skip: Int! = 0, cursor: TranscriptSegmentWhereUniqueInput): [TranscriptSegment!]
  segmentsCount(where: TranscriptSegmentWhereInput! = {}): Int
  segmentEmbeddingProgress: SegmentEmbeddingProgress
  createdAt: DateTime
  updatedAt: DateTime
}

enum TranscriptEmbeddingStatusType {
  pending
  processing
  completed
  failed
}

enum TranscriptImportStatusType {
  pending
  fetching
  completed
  failed
  skipped
}

type SegmentEmbeddingProgress {
  total: Int!
  embedded: Int!
  notEmbedded: Int!
  embeddedPercentage: Float!
  notEmbeddedPercentage: Float!
}

input TranscriptWhereUniqueInput {
  id: ID
}

input TranscriptWhereInput {
  AND: [TranscriptWhereInput!]
  OR: [TranscriptWhereInput!]
  NOT: [TranscriptWhereInput!]
  id: IDFilter
  title: StringFilter
  intervieweeName: StringFilter
  sourceUrl: StringFilter
  language: StringFilter
  notes: StringFilter
  externalId: StringFilter
  publishedAt: DateTimeNullableFilter
  duration: IntNullableFilter
  thumbnailUrl: StringFilter
  embeddingStatus: TranscriptEmbeddingStatusTypeNullableFilter
  embeddingAttempts: IntNullableFilter
  embeddingError: StringFilter
  embeddingAt: DateTimeNullableFilter
  importStatus: TranscriptImportStatusTypeNullableFilter
  importAttempts: IntNullableFilter
  importError: StringFilter
  importAt: DateTimeNullableFilter
  source: SourceWhereInput
  org: OrganizationWhereInput
  segments: TranscriptSegmentManyRelationFilter
  createdAt: DateTimeNullableFilter
  updatedAt: DateTimeNullableFilter
}

input IntNullableFilter {
  equals: Int
  in: [Int!]
  notIn: [Int!]
  lt: Int
  lte: Int
  gt: Int
  gte: Int
  not: IntNullableFilter
}

input TranscriptEmbeddingStatusTypeNullableFilter {
  equals: TranscriptEmbeddingStatusType
  in: [TranscriptEmbeddingStatusType!]
  notIn: [TranscriptEmbeddingStatusType!]
  not: TranscriptEmbeddingStatusTypeNullableFilter
}

input TranscriptImportStatusTypeNullableFilter {
  equals: TranscriptImportStatusType
  in: [TranscriptImportStatusType!]
  notIn: [TranscriptImportStatusType!]
  not: TranscriptImportStatusTypeNullableFilter
}

input TranscriptSegmentManyRelationFilter {
  every: TranscriptSegmentWhereInput
  some: TranscriptSegmentWhereInput
  none: TranscriptSegmentWhereInput
}

input TranscriptOrderByInput {
  id: OrderDirection
  title: OrderDirection
  intervieweeName: OrderDirection
  sourceUrl: OrderDirection
  language: OrderDirection
  notes: OrderDirection
  externalId: OrderDirection
  publishedAt: OrderDirection
  duration: OrderDirection
  thumbnailUrl: OrderDirection
  embeddingStatus: OrderDirection
  embeddingAttempts: OrderDirection
  embeddingError: OrderDirection
  embeddingAt: OrderDirection
  importStatus: OrderDirection
  importAttempts: OrderDirection
  importError: OrderDirection
  importAt: OrderDirection
  createdAt: OrderDirection
  updatedAt: OrderDirection
}

input TranscriptUpdateInput {
  title: String
  intervieweeName: String
  sourceUrl: String
  language: String
  notes: String
  externalId: String
  publishedAt: DateTime
  duration: Int
  thumbnailUrl: String
  embeddingStatus: TranscriptEmbeddingStatusType
  embeddingAttempts: Int
  embeddingError: String
  embeddingAt: DateTime
  importStatus: TranscriptImportStatusType
  importAttempts: Int
  importError: String
  importAt: DateTime
  source: SourceRelateToOneForUpdateInput
  org: OrganizationRelateToOneForUpdateInput
  segments: TranscriptSegmentRelateToManyForUpdateInput
  createdAt: DateTime
  updatedAt: DateTime
}

input SourceRelateToOneForUpdateInput {
  create: SourceCreateInput
  connect: SourceWhereUniqueInput
  disconnect: Boolean
}

input TranscriptSegmentRelateToManyForUpdateInput {
  disconnect: [TranscriptSegmentWhereUniqueInput!]
  set: [TranscriptSegmentWhereUniqueInput!]
  create: [TranscriptSegmentCreateInput!]
  connect: [TranscriptSegmentWhereUniqueInput!]
}

input TranscriptUpdateArgs {
  where: TranscriptWhereUniqueInput!
  data: TranscriptUpdateInput!
}

input TranscriptCreateInput {
  title: String
  intervieweeName: String
  sourceUrl: String
  language: String
  notes: String
  externalId: String
  publishedAt: DateTime
  duration: Int
  thumbnailUrl: String
  embeddingStatus: TranscriptEmbeddingStatusType
  embeddingAttempts: Int
  embeddingError: String
  embeddingAt: DateTime
  importStatus: TranscriptImportStatusType
  importAttempts: Int
  importError: String
  importAt: DateTime
  source: SourceRelateToOneForCreateInput
  org: OrganizationRelateToOneForCreateInput
  segments: TranscriptSegmentRelateToManyForCreateInput
  createdAt: DateTime
  updatedAt: DateTime
}

input SourceRelateToOneForCreateInput {
  create: SourceCreateInput
  connect: SourceWhereUniqueInput
}

input TranscriptSegmentRelateToManyForCreateInput {
  create: [TranscriptSegmentCreateInput!]
  connect: [TranscriptSegmentWhereUniqueInput!]
}

type TranscriptSegment {
  id: ID!
  transcript: Transcript
  source: Source
  index: Int
  startMs: Int
  endMs: Int
  durationMs: Int
  text: String
  speaker: String
  isMetadata: Boolean
}

input TranscriptSegmentWhereUniqueInput {
  id: ID
}

input TranscriptSegmentWhereInput {
  AND: [TranscriptSegmentWhereInput!]
  OR: [TranscriptSegmentWhereInput!]
  NOT: [TranscriptSegmentWhereInput!]
  id: IDFilter
  transcript: TranscriptWhereInput
  source: SourceWhereInput
  index: IntNullableFilter
  startMs: IntNullableFilter
  endMs: IntNullableFilter
  durationMs: IntNullableFilter
  text: StringFilter
  speaker: StringFilter
  isMetadata: BooleanFilter
}

input BooleanFilter {
  equals: Boolean
  not: BooleanFilter
}

input TranscriptSegmentOrderByInput {
  id: OrderDirection
  index: OrderDirection
  startMs: OrderDirection
  endMs: OrderDirection
  durationMs: OrderDirection
  text: OrderDirection
  speaker: OrderDirection
  isMetadata: OrderDirection
}

input TranscriptSegmentUpdateInput {
  transcript: TranscriptRelateToOneForUpdateInput
  source: SourceRelateToOneForUpdateInput
  index: Int
  startMs: Int
  endMs: Int
  durationMs: Int
  text: String
  speaker: String
  isMetadata: Boolean
}

input TranscriptRelateToOneForUpdateInput {
  create: TranscriptCreateInput
  connect: TranscriptWhereUniqueInput
  disconnect: Boolean
}

input TranscriptSegmentUpdateArgs {
  where: TranscriptSegmentWhereUniqueInput!
  data: TranscriptSegmentUpdateInput!
}

input TranscriptSegmentCreateInput {
  transcript: TranscriptRelateToOneForCreateInput
  source: SourceRelateToOneForCreateInput
  index: Int
  startMs: Int
  endMs: Int
  durationMs: Int
  text: String
  speaker: String
  isMetadata: Boolean
}

input TranscriptRelateToOneForCreateInput {
  create: TranscriptCreateInput
  connect: TranscriptWhereUniqueInput
}

type User {
  id: ID!
  avatarSocialUrl: String
  avatarUploaded: CloudinaryImage_File
  avatarUrl: String
  email: String
  firstName: String
  lastName: String
  displayName: String
  role: UserRoleType
  providerAccountId: String
  provider: UserProviderType
  rawAuth: JSON
  org: Organization
  chats(where: ChatWhereInput! = {}, orderBy: [ChatOrderByInput!]! = [], take: Int, skip: Int! = 0, cursor: ChatWhereUniqueInput): [Chat!]
  chatsCount(where: ChatWhereInput! = {}): Int
  isActive: Boolean
  createdAt: DateTime
  provisionedAt: DateTime
  updatedAt: DateTime
  seenAt: DateTime
}

type CloudinaryImage_File {
  id: ID
  filename: String
  originalFilename: String
  mimetype: String
  encoding: String
  publicUrl: String
  publicUrlTransformed(transformation: CloudinaryImageFormat): String
}

"""
Mirrors the formatting options [Cloudinary provides](https://cloudinary.com/documentation/image_transformation_reference).
All options are strings as they ultimately end up in a URL.
"""
input CloudinaryImageFormat {
  """ Rewrites the filename to be this pretty string. Do not include `/` or `.`
  """
  prettyName: String
  width: String
  height: String
  crop: String
  aspect_ratio: String
  gravity: String
  zoom: String
  x: String
  y: String
  format: String
  fetch_format: String
  quality: String
  radius: String
  angle: String
  effect: String
  opacity: String
  border: String
  background: String
  overlay: String
  underlay: String
  default_image: String
  delay: String
  color: String
  color_space: String
  dpr: String
  page: String
  density: String
  flags: String
  transformation: String
}

enum UserRoleType {
  USER
  ORG_ADMIN
  ORG_OWNER
  GOD
}

enum UserProviderType {
  google
}

input UserWhereUniqueInput {
  id: ID
  providerAccountId: String
}

input UserWhereInput {
  AND: [UserWhereInput!]
  OR: [UserWhereInput!]
  NOT: [UserWhereInput!]
  id: IDFilter
  avatarSocialUrl: StringFilter
  email: StringFilter
  firstName: StringFilter
  lastName: StringFilter
  role: UserRoleTypeNullableFilter
  providerAccountId: StringFilter
  provider: UserProviderTypeNullableFilter
  org: OrganizationWhereInput
  chats: ChatManyRelationFilter
  isActive: BooleanFilter
  createdAt: DateTimeNullableFilter
  provisionedAt: DateTimeNullableFilter
  updatedAt: DateTimeNullableFilter
  seenAt: DateTimeNullableFilter
}

input UserRoleTypeNullableFilter {
  equals: UserRoleType
  in: [UserRoleType!]
  notIn: [UserRoleType!]
  not: UserRoleTypeNullableFilter
}

input UserProviderTypeNullableFilter {
  equals: UserProviderType
  in: [UserProviderType!]
  notIn: [UserProviderType!]
  not: UserProviderTypeNullableFilter
}

input UserOrderByInput {
  id: OrderDirection
  avatarSocialUrl: OrderDirection
  email: OrderDirection
  firstName: OrderDirection
  lastName: OrderDirection
  role: OrderDirection
  providerAccountId: OrderDirection
  provider: OrderDirection
  isActive: OrderDirection
  createdAt: OrderDirection
  provisionedAt: OrderDirection
  updatedAt: OrderDirection
  seenAt: OrderDirection
}

input UserUpdateInput {
  avatarSocialUrl: String
  avatarUploaded: Upload
  email: String
  firstName: String
  lastName: String
  role: UserRoleType
  providerAccountId: String
  provider: UserProviderType
  rawAuth: JSON
  org: OrganizationRelateToOneForUpdateInput
  chats: ChatRelateToManyForUpdateInput
  isActive: Boolean
  createdAt: DateTime
  provisionedAt: DateTime
  updatedAt: DateTime
  seenAt: DateTime
}

"""The `Upload` scalar type represents a file upload."""
scalar Upload

input UserUpdateArgs {
  where: UserWhereUniqueInput!
  data: UserUpdateInput!
}

input UserCreateInput {
  avatarSocialUrl: String
  avatarUploaded: Upload
  email: String
  firstName: String
  lastName: String
  role: UserRoleType
  providerAccountId: String
  provider: UserProviderType
  rawAuth: JSON
  org: OrganizationRelateToOneForCreateInput
  chats: ChatRelateToManyForCreateInput
  isActive: Boolean
  createdAt: DateTime
  provisionedAt: DateTime
  updatedAt: DateTime
  seenAt: DateTime
}

"""
The `JSON` scalar type represents JSON values as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
"""
scalar JSON @specifiedBy(url: "http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf")

type Mutation {
  createChat(data: ChatCreateInput!): Chat
  createChats(data: [ChatCreateInput!]!): [Chat]
  updateChat(where: ChatWhereUniqueInput!, data: ChatUpdateInput!): Chat
  updateChats(data: [ChatUpdateArgs!]!): [Chat]
  deleteChat(where: ChatWhereUniqueInput!): Chat
  deleteChats(where: [ChatWhereUniqueInput!]!): [Chat]
  createChatMessage(data: ChatMessageCreateInput!): ChatMessage
  createChatMessages(data: [ChatMessageCreateInput!]!): [ChatMessage]
  updateChatMessage(where: ChatMessageWhereUniqueInput!, data: ChatMessageUpdateInput!): ChatMessage
  updateChatMessages(data: [ChatMessageUpdateArgs!]!): [ChatMessage]
  deleteChatMessage(where: ChatMessageWhereUniqueInput!): ChatMessage
  deleteChatMessages(where: [ChatMessageWhereUniqueInput!]!): [ChatMessage]
  createOrganization(data: OrganizationCreateInput!): Organization
  createOrganizations(data: [OrganizationCreateInput!]!): [Organization]
  updateOrganization(where: OrganizationWhereUniqueInput!, data: OrganizationUpdateInput!): Organization
  updateOrganizations(data: [OrganizationUpdateArgs!]!): [Organization]
  deleteOrganization(where: OrganizationWhereUniqueInput!): Organization
  deleteOrganizations(where: [OrganizationWhereUniqueInput!]!): [Organization]
  createProject(data: ProjectCreateInput!): Project
  createProjects(data: [ProjectCreateInput!]!): [Project]
  updateProject(where: ProjectWhereUniqueInput!, data: ProjectUpdateInput!): Project
  updateProjects(data: [ProjectUpdateArgs!]!): [Project]
  deleteProject(where: ProjectWhereUniqueInput!): Project
  deleteProjects(where: [ProjectWhereUniqueInput!]!): [Project]
  createSource(data: SourceCreateInput!): Source
  createSources(data: [SourceCreateInput!]!): [Source]
  updateSource(where: SourceWhereUniqueInput!, data: SourceUpdateInput!): Source
  updateSources(data: [SourceUpdateArgs!]!): [Source]
  deleteSource(where: SourceWhereUniqueInput!): Source
  deleteSources(where: [SourceWhereUniqueInput!]!): [Source]
  createTranscript(data: TranscriptCreateInput!): Transcript
  createTranscripts(data: [TranscriptCreateInput!]!): [Transcript]
  updateTranscript(where: TranscriptWhereUniqueInput!, data: TranscriptUpdateInput!): Transcript
  updateTranscripts(data: [TranscriptUpdateArgs!]!): [Transcript]
  deleteTranscript(where: TranscriptWhereUniqueInput!): Transcript
  deleteTranscripts(where: [TranscriptWhereUniqueInput!]!): [Transcript]
  createTranscriptSegment(data: TranscriptSegmentCreateInput!): TranscriptSegment
  createTranscriptSegments(data: [TranscriptSegmentCreateInput!]!): [TranscriptSegment]
  updateTranscriptSegment(where: TranscriptSegmentWhereUniqueInput!, data: TranscriptSegmentUpdateInput!): TranscriptSegment
  updateTranscriptSegments(data: [TranscriptSegmentUpdateArgs!]!): [TranscriptSegment]
  deleteTranscriptSegment(where: TranscriptSegmentWhereUniqueInput!): TranscriptSegment
  deleteTranscriptSegments(where: [TranscriptSegmentWhereUniqueInput!]!): [TranscriptSegment]
  createUser(data: UserCreateInput!): User
  createUsers(data: [UserCreateInput!]!): [User]
  updateUser(where: UserWhereUniqueInput!, data: UserUpdateInput!): User
  updateUsers(data: [UserUpdateArgs!]!): [User]
  deleteUser(where: UserWhereUniqueInput!): User
  deleteUsers(where: [UserWhereUniqueInput!]!): [User]
  endSession: Boolean!
  triggerSourceImport(sourceId: ID!): Source!
  chatTranscript(input: ChatTranscriptInput!): ChatMutationResult!
  chatProject(input: ChatProjectInput!): ChatMutationResult!
}

type ChatMutationResult {
  chatId: ID!
  answer: String!
  messages: [ChatMessageResult!]!
  references: [ChatSegmentReference!]!
}

type ChatMessageResult {
  id: ID!
  role: String!
  content: String!
  createdAt: String
  debugData: ChatMessageDebugData
}

type ChatMessageDebugData {
  config: ChatConfig!
  resolvedSystemPrompt: String!
  userMessageWithContext: String!
  history: ChatMessageDebugHistory!
  segments: [ChatMessageDebugSegment!]
  segmentTokensUsed: Int!
  openaiResponse: ChatMessageDebugOpenAIResponse!
  timing: ChatMessageDebugTiming!
}

type ChatConfig {
  systemPrompt: String!
  openai: ChatConfigOpenAI!
  context: ChatConfigContext!
  segments: ChatConfigSegments!
}

type ChatConfigOpenAI {
  model: String!
  temperature: Float!
  maxOutputTokens: Int!
}

type ChatConfigContext {
  maxInputTokens: Int!
  reservedTokens: Int!
  historyTokenBudget: Int!
}

type ChatConfigSegments {
  tokenBudget: Int!
  maxCount: Int!
}

type ChatMessageDebugHistory {
  messagesIncluded: Int!
  tokensUsed: Int!
  tokenBudget: Int!
  messages: [ChatMessageDebugHistoryMessage!]!
}

type ChatMessageDebugHistoryMessage {
  role: String!
  content: String!
  tokens: Int!
}

type ChatMessageDebugSegment {
  id: ID!
  text: String!
  transcriptTitle: String
  speaker: String
  startMs: Int
  endMs: Int
  similarityScore: Float
  estimatedTokens: Int!
}

type ChatMessageDebugOpenAIResponse {
  model: String!
  promptTokens: Int
  completionTokens: Int
  totalTokens: Int
}

type ChatMessageDebugTiming {
  startedAt: String!
  completedAt: String!
}

type ChatSegmentReference {
  id: ID!
  text: String!
  startMs: Int
  endMs: Int
  speaker: String
  transcriptTitle: String
}

input ChatTranscriptInput {
  chatId: ID
  transcriptId: ID!
  message: String!
  systemPrompt: String!
  config: ChatConfigInput
}

input ChatConfigInput {
  systemPrompt: String
  openai: ChatConfigOpenAIInput
  context: ChatConfigContextInput
  segments: ChatConfigSegmentsInput
}

input ChatConfigOpenAIInput {
  model: String
  temperature: Float
  maxOutputTokens: Int
}

input ChatConfigContextInput {
  maxInputTokens: Int
  reservedTokens: Int
  historyTokenBudget: Int
}

input ChatConfigSegmentsInput {
  tokenBudget: Int
  maxCount: Int
}

input ChatProjectInput {
  chatId: ID
  projectId: ID!
  message: String!
  systemPrompt: String!
  config: ChatConfigInput
}

type Query {
  chat(where: ChatWhereUniqueInput!): Chat
  chats(where: ChatWhereInput! = {}, orderBy: [ChatOrderByInput!]! = [], take: Int, skip: Int! = 0, cursor: ChatWhereUniqueInput): [Chat!]
  chatsCount(where: ChatWhereInput! = {}): Int
  chatMessage(where: ChatMessageWhereUniqueInput!): ChatMessage
  chatMessages(where: ChatMessageWhereInput! = {}, orderBy: [ChatMessageOrderByInput!]! = [], take: Int, skip: Int! = 0, cursor: ChatMessageWhereUniqueInput): [ChatMessage!]
  chatMessagesCount(where: ChatMessageWhereInput! = {}): Int
  organization(where: OrganizationWhereUniqueInput!): Organization
  organizations(where: OrganizationWhereInput! = {}, orderBy: [OrganizationOrderByInput!]! = [], take: Int, skip: Int! = 0, cursor: OrganizationWhereUniqueInput): [Organization!]
  organizationsCount(where: OrganizationWhereInput! = {}): Int
  project(where: ProjectWhereUniqueInput!): Project
  projects(where: ProjectWhereInput! = {}, orderBy: [ProjectOrderByInput!]! = [], take: Int, skip: Int! = 0, cursor: ProjectWhereUniqueInput): [Project!]
  projectsCount(where: ProjectWhereInput! = {}): Int
  source(where: SourceWhereUniqueInput!): Source
  sources(where: SourceWhereInput! = {}, orderBy: [SourceOrderByInput!]! = [], take: Int, skip: Int! = 0, cursor: SourceWhereUniqueInput): [Source!]
  sourcesCount(where: SourceWhereInput! = {}): Int
  transcript(where: TranscriptWhereUniqueInput!): Transcript
  transcripts(where: TranscriptWhereInput! = {}, orderBy: [TranscriptOrderByInput!]! = [], take: Int, skip: Int! = 0, cursor: TranscriptWhereUniqueInput): [Transcript!]
  transcriptsCount(where: TranscriptWhereInput! = {}): Int
  transcriptSegment(where: TranscriptSegmentWhereUniqueInput!): TranscriptSegment
  transcriptSegments(where: TranscriptSegmentWhereInput! = {}, orderBy: [TranscriptSegmentOrderByInput!]! = [], take: Int, skip: Int! = 0, cursor: TranscriptSegmentWhereUniqueInput): [TranscriptSegment!]
  transcriptSegmentsCount(where: TranscriptSegmentWhereInput! = {}): Int
  user(where: UserWhereUniqueInput!): User
  users(where: UserWhereInput! = {}, orderBy: [UserOrderByInput!]! = [], take: Int, skip: Int! = 0, cursor: UserWhereUniqueInput): [User!]
  usersCount(where: UserWhereInput! = {}): Int
  keystone: KeystoneMeta!
  chatTranscriptHistory(transcriptId: ID!, chatId: ID): ChatHistoryResult!
  chatProjectHistory(projectId: ID!, chatId: ID): ChatHistoryResult!
}

type ChatHistoryResult {
  chatId: ID
  title: String
  messages: [ChatMessageResult!]!
  systemPrompt: String
  resolvedSystemPrompt: String
  config: ChatConfig
}

type KeystoneMeta {
  adminMeta: KeystoneAdminMeta!
}

type KeystoneAdminMeta {
  lists: [KeystoneAdminUIListMeta!]!
  list(key: String!): KeystoneAdminUIListMeta
}

type KeystoneAdminUIListMeta {
  key: String!
  path: String!
  label: String!
  singular: String!
  plural: String!
  description: String
  pageSize: Int!
  labelField: String!
  fields: [KeystoneAdminUIFieldMeta!]!
  groups: [KeystoneAdminUIFieldGroupMeta!]!
  graphql: KeystoneAdminUIGraphQL!
  initialColumns: [String!]!
  initialSearchFields: [String!]!
  initialSort: KeystoneAdminUISort
  isSingleton: Boolean!
  hideCreate: Boolean!
  hideDelete: Boolean!
  isHidden: Boolean!
  itemQueryName: String!
  listQueryName: String!
}

type KeystoneAdminUIFieldMeta {
  path: String!
  label: String!
  description: String
  isOrderable: Boolean!
  isFilterable: Boolean!
  isNonNull: [KeystoneAdminUIFieldMetaIsNonNull!]
  fieldMeta: JSON
  viewsIndex: Int!
  customViewsIndex: Int
  createView: KeystoneAdminUIFieldMetaCreateView!
  listView: KeystoneAdminUIFieldMetaListView!
  itemView(id: ID): KeystoneAdminUIFieldMetaItemView
  search: QueryMode
}

enum KeystoneAdminUIFieldMetaIsNonNull {
  read
  create
  update
}

type KeystoneAdminUIFieldMetaCreateView {
  fieldMode: KeystoneAdminUIFieldMetaCreateViewFieldMode!
}

enum KeystoneAdminUIFieldMetaCreateViewFieldMode {
  edit
  hidden
}

type KeystoneAdminUIFieldMetaListView {
  fieldMode: KeystoneAdminUIFieldMetaListViewFieldMode!
}

enum KeystoneAdminUIFieldMetaListViewFieldMode {
  read
  hidden
}

type KeystoneAdminUIFieldMetaItemView {
  fieldMode: KeystoneAdminUIFieldMetaItemViewFieldMode
  fieldPosition: KeystoneAdminUIFieldMetaItemViewFieldPosition
}

enum KeystoneAdminUIFieldMetaItemViewFieldMode {
  edit
  read
  hidden
}

enum KeystoneAdminUIFieldMetaItemViewFieldPosition {
  form
  sidebar
}

type KeystoneAdminUIFieldGroupMeta {
  label: String!
  description: String
  fields: [KeystoneAdminUIFieldMeta!]!
}

type KeystoneAdminUIGraphQL {
  names: KeystoneAdminUIGraphQLNames!
}

type KeystoneAdminUIGraphQLNames {
  outputTypeName: String!
  whereInputName: String!
  whereUniqueInputName: String!
  createInputName: String!
  createMutationName: String!
  createManyMutationName: String!
  relateToOneForCreateInputName: String!
  relateToManyForCreateInputName: String!
  itemQueryName: String!
  listOrderName: String!
  listQueryCountName: String!
  listQueryName: String!
  updateInputName: String!
  updateMutationName: String!
  updateManyInputName: String!
  updateManyMutationName: String!
  relateToOneForUpdateInputName: String!
  relateToManyForUpdateInputName: String!
  deleteMutationName: String!
  deleteManyMutationName: String!
}

type KeystoneAdminUISort {
  field: String!
  direction: KeystoneAdminUISortDirection!
}

enum KeystoneAdminUISortDirection {
  ASC
  DESC
}
